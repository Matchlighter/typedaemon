#!/bin/bash

findconfig() {
  if [ -f "$1" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [ "$PWD" = / ]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && findconfig "$1")
  fi
}

findsocket() {
  if [ -S "$1" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [ "$PWD" = / ]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && findsocket "$1")
  fi
}

function findexec() {
    if [ -x "$(command -v $1)" ]; then
        echo "$(which "$1")"
    else
        echo "$(findconfig "./typedaemon/bin/$1")"
    fi
}

conn_params="$(findconfig .typedaemon/connection_params)"

source "$conn_params"

if [ "$TD_CONNECTION_MODE" = "SSH" ]; then
  key_file="$(mktemp)"
  socket="$(findsocket .typedaemon/ssh_sock)"
  proxy_cmd=""

  if [ -x "$(command -v nc)" ]; then
    proxy_cmd="nc -U $socket"
  elif [ -x "$(command -v socat)" ]; then
    proxy_cmd="socat - UNIX-CLIENT:$socket"
  else
    echo "socat or netcat must be installed"
    exit 1
  fi

  # SSH has a lot of bloat for this use case. I wanted to find something simpler, but nothing I could find "just worked" as well at runtime

  cat "$(findconfig .typedaemon/connection_key)" > "$key_file"
  chmod 700 "$key_file"

  if [ "$1" = "shell" ]; then
    exec "ssh" -t -o StrictHostKeyChecking=no -i $key_file -o "ProxyCommand $proxy_cmd" root@td 'cd '$(pwd)'; exec "$SHELL" -l'
  elif [ "$1" = "exec" ]; then
    shift
    exec "ssh" -o StrictHostKeyChecking=no -i $key_file -o "ProxyCommand $proxy_cmd" root@td 'cd '$(pwd)'; exec' "$@"
  else
    exec "ssh" -o StrictHostKeyChecking=no -i $key_file -o "ProxyCommand $proxy_cmd" root@td 'cd '$(pwd)'; exec "td"' "$@"
  fi
elif [ "$TD_CONNECTION_MODE" = "DOCKER" ]; then
  exec docker run --rm -it -v $PWD:/config typedaemon td "$@"
elif [ -x "$(command -v td)" ]; then
  exec td "$@"
fi
